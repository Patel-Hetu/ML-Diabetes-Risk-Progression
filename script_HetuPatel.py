# -*- coding: utf-8 -*-
"""script_HetuPatel

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-PwyX52YvBU0PxkjpPSL9_7tXkOFlcZu
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler

# Correct raw CSV URL
url = 'https://raw.githubusercontent.com/Patel-Hetu/ML-Diabetes-Risk-Progression-Stage/main/diabetes-dataset.csv'

# Column names based on the dataset description
column_names = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age', 'Outcome']

# Load the dataset into a DataFrame
try:
    data = pd.read_csv(url, names=column_names, on_bad_lines='skip')  # Skip problematic rows
except Exception as e:
    print(f"Error loading data: {e}")

# Show the first few rows of the dataset
print(data.head())

# Importing necessary libraries
import pandas as pd
import numpy as np

# URL of the raw CSV file on GitHub
url = 'https://raw.githubusercontent.com/Patel-Hetu/ML-Diabetes-Risk-Progression/main/diabetes-dataset.csv'

# Column names based on the dataset description
column_names = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age', 'Outcome']

# Load the dataset into a DataFrame
data = pd.read_csv(url, names=column_names)

# Convert columns to appropriate numeric types (ensure no accidental object dtype)
data = data.apply(pd.to_numeric, errors='coerce')

# Checking for missing values and replacing zeros with NaN for columns where zeros are invalid
data.replace(0, np.nan, inplace=True)

# Impute missing values with the median of each numeric column
# Exclude the 'Outcome' column as it's categorical
numeric_data = data.drop(columns=['Outcome'])
data[numeric_data.columns] = numeric_data.fillna(numeric_data.median())

# Verify that missing values are handled
print(data.isnull().sum())

# Check for missing values after imputation
print("Missing values after imputation:")
print(data.isnull().sum())

# Check for any remaining zeros in relevant columns
zero_rows = data[(data[['Glucose', 'Insulin', 'BMI', 'BloodPressure']] == 0).any(axis=1)]
print("Rows with zeros that should have been replaced:")
print(zero_rows)

# Verify the summary statistics to see if median imputation was successful
print("Summary statistics after imputation:")
print(data.describe())

# Checking a few rows after imputation to see if the values look reasonable
print(data.head())

# Initialize the MinMaxScaler
scaler = MinMaxScaler()

# Normalize all features (excluding the 'Outcome' column)
features = data.drop(columns=['Outcome'])
scaled_features = scaler.fit_transform(features)

# Convert the scaled features back into a DataFrame for ease of use
scaled_data = pd.DataFrame(scaled_features, columns=features.columns)

# Show the first few rows of the scaled data
scaled_data.head()

# Pairplot to visualize relationships between features
sns.pairplot(scaled_data)
plt.show()

# Correlation matrix heatmap
correlation_matrix = scaled_data.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix')
plt.show()

from sklearn.cluster import KMeans

# Calculate inertia for different values of k (number of clusters)
inertia = []
k_range = range(1, 11)
for k in k_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(scaled_data)
    inertia.append(kmeans.inertia_)

# Plot the Elbow Method graph
plt.figure(figsize=(8, 6))
plt.plot(k_range, inertia, marker='o')
plt.title('Elbow Method for Optimal k')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Inertia')
plt.show()

# Fit K-Means clustering with the optimal number of clusters (e.g., k=3)
kmeans = KMeans(n_clusters=3, random_state=42)
data['Cluster'] = kmeans.fit_predict(scaled_data)

# Visualizing the clusters using PCA for dimensionality reduction (2D plot)
from sklearn.decomposition import PCA

# Reduce to 2D using PCA
pca = PCA(n_components=2)
pca_components = pca.fit_transform(scaled_data)

# Plot the clusters
plt.figure(figsize=(8, 6))
plt.scatter(pca_components[:, 0], pca_components[:, 1], c=data['Cluster'], cmap='viridis')
plt.title('K-Means Clusters (PCA-reduced)')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.colorbar(label='Cluster')
plt.show()

# Filter low-risk group (Cluster 0)
low_risk_group = data[data['Cluster'] == 0]

# Plot for Glucose vs BMI (Low-Risk Group)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=low_risk_group['Glucose'], y=low_risk_group['BMI'], hue=low_risk_group['Cluster'], palette='viridis')
plt.title('Low-Risk Group: Glucose vs BMI')
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.show()

# Filter medium-risk group (Cluster 1)
medium_risk_group = data[data['Cluster'] == 1]

# Plot for Glucose vs BMI (Medium-Risk Group)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=medium_risk_group['Glucose'], y=medium_risk_group['BMI'], hue=medium_risk_group['Cluster'], palette='viridis')
plt.title('Medium-Risk Group: Glucose vs BMI')
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.show()

# Filter high-risk group (Cluster 2)
high_risk_group = data[data['Cluster'] == 2]

# Plot for Glucose vs BMI (High-Risk Group)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=high_risk_group['Glucose'], y=high_risk_group['BMI'], hue=high_risk_group['Cluster'], palette='viridis')
plt.title('High-Risk Group: Glucose vs BMI')
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.show()

# Plot for Glucose vs Insulin (Early Stage)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=medium_risk_group['Glucose'], y=medium_risk_group['Insulin'], hue=medium_risk_group['Cluster'], palette='viridis')
plt.title('Early Stage/Prediabetes: Glucose vs Insulin')
plt.xlabel('Glucose')
plt.ylabel('Insulin')
plt.show()

# Plot for Glucose vs Insulin (Intermediate Stage)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=high_risk_group['Glucose'], y=high_risk_group['Insulin'], hue=high_risk_group['Cluster'], palette='viridis')
plt.title('Intermediate Stage: Glucose vs Insulin')
plt.xlabel('Glucose')
plt.ylabel('Insulin')
plt.show()

# Plot for Glucose vs BMI (Advanced Stage)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=high_risk_group['Glucose'], y=high_risk_group['BMI'], hue=high_risk_group['Cluster'], palette='viridis')
plt.title('Advanced Stage: Glucose vs BMI')
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.show()

# Ensure that 'Glucose', 'BMI', and 'Insulin' columns are numeric
data['Glucose'] = pd.to_numeric(data['Glucose'], errors='coerce')
data['BMI'] = pd.to_numeric(data['BMI'], errors='coerce')
data['Insulin'] = pd.to_numeric(data['Insulin'], errors='coerce')

# Handle missing values (e.g., by filling with the mean of each column) only for numeric columns
numeric_columns = ['Glucose', 'BMI', 'Insulin']
data[numeric_columns] = data[numeric_columns].fillna(data[numeric_columns].mean())

# Check if the 'Cluster' column exists, if not, perform clustering
if 'Cluster' not in data.columns:
    # Apply KMeans clustering
    features = data[['Glucose', 'BMI', 'Insulin']]  # Select features for clustering
    kmeans = KMeans(n_clusters=3, random_state=42)  # You can adjust the number of clusters
    data['Cluster'] = kmeans.fit_predict(features)

# Calculate the mean values for Glucose, BMI, and Insulin for each risk group (Cluster)
grouped_data = data.groupby('Cluster')[['Glucose', 'BMI', 'Insulin']].mean().reset_index()

# Prepare the data for the radar chart
categories = ['Glucose', 'BMI', 'Insulin']

# Assuming the cluster numbering starts from 0 and there are 3 clusters (Low, Medium, High risk)
values_low = grouped_data.iloc[0, 1:].values  # Values for Cluster 0 (Low Risk)
values_medium = grouped_data.iloc[1, 1:].values  # Values for Cluster 1 (Medium Risk)
values_high = grouped_data.iloc[2, 1:].values  # Values for Cluster 2 (High Risk)

# Number of categories (Glucose, BMI, Insulin)
num_categories = len(categories)

# Angle for each axis (divide 2pi by the number of categories)
angles = np.linspace(0, 2 * np.pi, num_categories, endpoint=False).tolist()

# Close the loop by appending the first value to the end for plotting
values_low = np.concatenate((values_low, [values_low[0]]))
values_medium = np.concatenate((values_medium, [values_medium[0]]))
values_high = np.concatenate((values_high, [values_high[0]]))
angles += angles[:1]  # Close the loop for the angles

# Create the radar chart
fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))

# Plot each risk group
ax.plot(angles, values_low, linewidth=1, linestyle='solid', label='Low Risk', color='green')
ax.fill(angles, values_low, alpha=0.25, color='green')

ax.plot(angles, values_medium, linewidth=1, linestyle='solid', label='Medium Risk', color='yellow')
ax.fill(angles, values_medium, alpha=0.25, color='yellow')

ax.plot(angles, values_high, linewidth=1, linestyle='solid', label='High Risk', color='red')
ax.fill(angles, values_high, alpha=0.25, color='red')

# Add labels for the axes
ax.set_yticklabels([])  # No radial ticks
ax.set_xticks(angles[:-1])  # Set x-axis labels to the categories
ax.set_xticklabels(categories)

# Add a legend
plt.legend(loc='upper right', bbox_to_anchor=(1.1, 1.1))

# Title and display
plt.title('Comparison of Low, Medium, and High Risk Groups Across Glucose, BMI, and Insulin', size=14)
plt.show()

# Replace cluster labels (0, 1, 2) with Early, Intermediate, Advanced stages
data['Stage'] = data['Cluster'].map({0: 'Early Stage', 1: 'Intermediate Stage', 2: 'Advanced Stage'})

# Melt the data to long format for easier plotting
data_melted = data.melt(id_vars='Stage', value_vars=['Glucose', 'Insulin', 'BMI'],
                        var_name='Feature', value_name='Value')

# Create bar plot
plt.figure(figsize=(10, 6))
sns.barplot(x='Feature', y='Value', hue='Stage', data=data_melted, palette='coolwarm')
plt.title('Average Glucose, Insulin, and BMI Across Diabetes Stages')
plt.xlabel('Feature')
plt.ylabel('Average Value')
plt.show()

# Replace cluster labels (0, 1, 2) with Early, Intermediate, Advanced stages
data['Stage'] = data['Cluster'].map({0: 'Early Stage', 1: 'Intermediate Stage', 2: 'Advanced Stage'})

# Create pairplot to visualize relationships between Glucose, Insulin, and BMI across stages
sns.pairplot(data, hue='Stage', vars=['Glucose', 'Insulin', 'BMI'], palette='coolwarm')
plt.suptitle('Pairplot of Glucose, Insulin, and BMI by Diabetes Stage', y=1.02)
plt.show()

# Import necessary libraries
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.impute import SimpleImputer

column_names = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age', 'Outcome']
data = pd.read_csv(url, names=column_names)

# Convert columns to numeric values
data = data.apply(pd.to_numeric, errors='coerce')

# Standardize the features (excluding 'Outcome')
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data.drop(columns=['Outcome']))

# Check if there are any NaN values in the scaled data
if np.any(np.isnan(data_scaled)):
    print("NaN values found in scaled data. Imputing with median values.")
    # Impute any NaN values that might have appeared during scaling
    data_scaled = imputer.fit_transform(data_scaled)

# K-Means Clustering for Risk Groups (Low, Medium, High)
kmeans_risk = KMeans(n_clusters=3, random_state=42)
data['RiskGroup_KMeans'] = kmeans_risk.fit_predict(data_scaled)

# Assign custom labels to the Risk Group clusters
risk_labels = {0: 'Low', 1: 'Medium', 2: 'High'}
data['RiskGroup_KMeans'] = data['RiskGroup_KMeans'].map(risk_labels)

# K-Means Clustering for Diabetes Stages (Early, Intermediate, Advanced)
kmeans_stage = KMeans(n_clusters=3, random_state=42)
data['Stage_KMeans'] = kmeans_stage.fit_predict(data_scaled)

# Assign custom labels to the Diabetes Stage clusters
stage_labels = {0: 'Early', 1: 'Intermediate', 2: 'Advanced'}
data['Stage_KMeans'] = data['Stage_KMeans'].map(stage_labels)

# Define solid colors for better distinction
risk_palette = {'Low': 'green', 'Medium': 'yellow', 'High': 'red'}
stage_palette = {'Early': 'blue', 'Intermediate': 'orange', 'Advanced': 'purple'}

# Plotting the K-Means results for Risk Groups
plt.figure(figsize=(12, 6))
sns.scatterplot(x=data['Glucose'], y=data['BMI'], hue=data['RiskGroup_KMeans'], palette=risk_palette, s=100, alpha=0.7, marker='o')
plt.title('K-Means Clustering: Risk Groups (Low, Medium, High)', fontsize=14)
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.legend(title='Risk Group')
plt.show()

# Plotting the K-Means results for Diabetes Stages
plt.figure(figsize=(12, 6))
sns.scatterplot(x=data['Glucose'], y=data['BMI'], hue=data['Stage_KMeans'], palette=stage_palette, s=100, alpha=0.7, marker='o')
plt.title('K-Means Clustering: Diabetes Stages (Early, Intermediate, Advanced)', fontsize=14)
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.legend(title='Diabetes Stage')
plt.show()

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import AgglomerativeClustering

# Convert columns to appropriate numeric types
data = data.apply(pd.to_numeric, errors='coerce')

# Check if there are any NaN values in the scaled data
if np.any(np.isnan(data_scaled)):
    print("NaN values found in scaled data. Imputing with median values.")
    # Impute any NaN values that might have appeared during scaling
    from sklearn.impute import SimpleImputer
    imputer = SimpleImputer(strategy='median')
    data_scaled = imputer.fit_transform(data_scaled)

# Perform Agglomerative Clustering for Risk Groups (Low, Medium, High)
agg_risk = AgglomerativeClustering(n_clusters=3)
data['RiskGroup_Hierarchical'] = agg_risk.fit_predict(data_scaled)

# Assign custom labels to the Risk Group clusters
risk_labels = {0: 'Low', 1: 'Medium', 2: 'High'}
data['RiskGroup_Hierarchical'] = data['RiskGroup_Hierarchical'].map(risk_labels)

# Perform Agglomerative Clustering for Diabetes Stages (Early, Intermediate, Advanced)
agg_stage = AgglomerativeClustering(n_clusters=3)
data['Stage_Hierarchical'] = agg_stage.fit_predict(data_scaled)

# Assign custom labels to the Diabetes Stage clusters
stage_labels = {0: 'Early', 1: 'Intermediate', 2: 'Advanced'}
data['Stage_Hierarchical'] = data['Stage_Hierarchical'].map(stage_labels)

# Define solid colors for better distinction
risk_palette = {'Low': 'green', 'Medium': 'yellow', 'High': 'red'}
stage_palette = {'Early': 'blue', 'Intermediate': 'orange', 'Advanced': 'purple'}

# Plotting the Agglomerative Clustering results for Risk Groups
plt.figure(figsize=(12, 6))
sns.scatterplot(x=data['Glucose'], y=data['BMI'], hue=data['RiskGroup_Hierarchical'], palette=risk_palette, s=100, alpha=0.7, marker='o')
plt.title('Agglomerative Clustering: Risk Groups (Low, Medium, High)', fontsize=14)
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.legend(title='Risk Group')
plt.show()

# Plotting the Agglomerative Clustering results for Diabetes Stages
plt.figure(figsize=(12, 6))
sns.scatterplot(x=data['Glucose'], y=data['BMI'], hue=data['Stage_Hierarchical'], palette=stage_palette, s=100, alpha=0.7, marker='o')
plt.title('Agglomerative Clustering: Diabetes Stages (Early, Intermediate, Advanced)', fontsize=14)
plt.xlabel('Glucose')
plt.ylabel('BMI')
plt.legend(title='Diabetes Stage')
plt.show()